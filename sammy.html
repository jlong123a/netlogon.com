<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Word Sandwich</title>
  <style>
    * { box-sizing: border-box; }
    :root {
      --p1: #93c5fd;
      --p2: #86efac;
      --muted: #64748b;
    }
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 8px;
      background: #f8fafc;
      color: #0f172a;
    }
    .wrap { max-width: 980px; margin: 0 auto; }
    h1 { margin: 0 0 8px; display: flex; align-items: center; justify-content: center; gap: 8px; font-size: 1.1rem; }
    .row { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; }
    .board {
      min-height: 42px;
      padding: 4px 0;
      width: 100%;
      gap: 0;
      overflow-x: auto;
      flex-wrap: nowrap;
      -webkit-overflow-scrolling: touch;
    }
    .board > * { flex: 0 0 auto; }
    .cell, .entry {
      width: 26px;
      height: 26px;
      border-radius: 5px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: .75rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: .02em;
    }
    .cell { color: #0f172a; border: 1px solid rgba(15, 23, 42, 0.22); }
    .p1 { background: var(--p1); }
    .p2 { background: var(--p2); }
    .entry {
      border: 2px dashed #94a3b8;
      outline: none;
      background: #ffffff;
      text-align: center;
      font-size: 16px;
      font-weight: 500;
    }
    .entry.p1 { border-color: var(--p1); color: var(--p1); }
    .entry.p2 { border-color: var(--p2); color: var(--p2); }
    .btn {
      border: 1px solid #334155;
      background: white;
      color: #334155;
      padding: 4px 8px;
      min-height: 30px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
    }
    .btn.warn { border-color: #7c2d12; background: #fff7ed; color: #9a3412; }
    .btn.ok { border-color: #14532d; background: #ecfdf5; color: #166534; }
    .btn:disabled { opacity: .6; cursor: not-allowed; }
    .cards {
      margin-top: 8px;
      display: grid;
      gap: 6px;
      width: 100%;
      max-width: 720px;
      grid-template-columns: 1fr;
    }
    .card {
      border: 1px solid #cbd5e1;
      border-radius: 8px;
      padding: 8px;
      min-width: 0;
      width: 100%;
      background: #f8fafc;
      transition: .12s ease all;
    }
    .card.active { opacity: 1; transform: scale(1); }
    .card.inactive { opacity: .7; transform: scale(.99); }
    .card.win { background: #ecfdf5; }
    .card.lose { background: #fff1f2; }
    .card-head {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 6px;
    }
    .title { font-weight: 700; margin-bottom: 0; font-size: 13px; }
    .meta { color: #334155; font-size: 11px; white-space: nowrap; }
    ul { margin: 6px 0 0; padding-left: 14px; font-size: 11px; }
    li { margin-bottom: 2px; }
    .card .btn {
      width: auto;
      min-height: 24px;
      padding: 2px 6px;
      font-size: 11px;
    }
    .word-info {
      margin-top: 6px;
      padding: 6px;
      border: 1px solid #cbd5e1;
      border-radius: 6px;
      background: #ffffff;
      font-size: 11px;
      line-height: 1.3;
      color: #0f172a;
    }
    .word-info .label {
      color: #475569;
      font-weight: 600;
    }
    .settings {
      margin-top: 8px;
      border: 1px solid #cbd5e1;
      border-radius: 8px;
      background: #ffffff;
      padding: 0;
      max-width: 720px;
      overflow: hidden;
    }
    .settings summary {
      cursor: pointer;
      font-size: 12px;
      font-weight: 700;
      color: #0f172a;
      list-style: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      background: #eef2f7;
      border-bottom: 1px solid #cbd5e1;
    }
    .settings summary::-webkit-details-marker { display: none; }
    .settings summary::after {
      content: 'â–¾';
      font-size: 12px;
      color: #475569;
    }
    .settings:not([open]) summary::after { content: 'â–¸'; }
    .settings-grid {
      margin-top: 0;
      display: grid;
      gap: 8px;
      padding: 8px;
    }
    .field label {
      display: block;
      font-size: 11px;
      color: #475569;
      margin-bottom: 2px;
    }
    .field input, .field select {
      width: 100%;
      min-height: 26px;
      border: 1px solid #cbd5e1;
      border-radius: 6px;
      padding: 3px 6px;
      font-size: 12px;
      background: #fff;
      color: #0f172a;
    }
    .timer-fields {
      display: grid;
      grid-template-columns: 1fr 110px;
      gap: 8px;
      align-items: end;
    }
    .timer-status {
      margin-top: 2px;
      font-size: 11px;
      color: #475569;
      min-height: 14px;
    }
    .checkbox-row {
      display: flex;
      align-items: center;
      gap: 6px;
      min-height: 26px;
      font-size: 12px;
      color: #0f172a;
      font-weight: 400;
    }
    .checkbox-row input[type="checkbox"] {
      width: auto;
      min-height: 0;
      margin: 0;
    }

    @media (max-width: 640px) {
      body { padding: 6px; }
      h1 { font-size: 1rem; line-height: 1.15; margin-bottom: 6px; }
      .row { gap: 6px; }
      .board { gap: 0; }
      .timer-fields { grid-template-columns: 1fr 92px; }
      .cell, .entry {
        width: 24px;
        height: 24px;
        border-radius: 4px;
        font-size: .7rem;
      }
      #newRound { width: 100%; min-height: 30px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1><span style="font-size:1.5em">ðŸ¥–</span> Word Sandwich<span style="font-size:1.5em">ðŸ¥–</span></h1>

    <div class="row board" id="board"></div>

    <div class="row" style="margin-top: 4px;">
      <button class="btn" id="newRound">New Round</button>
    </div>
    <div class="timer-status" id="timerStatus"></div>

    <div class="cards" id="cards"></div>

    <details class="settings" open>
      <summary>Settings</summary>
      <div class="settings-grid">
        <div class="field">
          <label for="langMode">Language</label>
          <select id="langMode">
            <option value="en" selected>English</option>
            <option value="fr">French</option>
            <option value="en-fr">English + French</option>
          </select>
        </div>
        <div class="field">
          <label for="player1Name">Player 1 Name</label>
          <input id="player1Name" type="text" maxlength="24" placeholder="Player 1" />
        </div>
        <div class="field">
          <label for="player2Name">Player 2 Name</label>
          <input id="player2Name" type="text" maxlength="24" placeholder="Player 2" />
        </div>
        <div class="timer-fields">
          <div class="field">
            <label for="enableTimer">Turn Timer</label>
            <div class="checkbox-row">
              <input id="enableTimer" type="checkbox" />
              <span>Enable timer</span>
            </div>
          </div>
          <div class="field">
            <label for="timerSeconds">Seconds</label>
            <input id="timerSeconds" type="number" min="3" max="120" step="1" value="10" />
          </div>
        </div>
      </div>
    </details>
  </div>

  <script>
    const state = {
      letters: [], // {char, player}
      turn: 1,
      mode: 'normal', // normal | challenge
      challengeBy: null,
      challengeDefender: null,
      ended: false,
      validating: false,
      winner: null,
      starter: 1,
      score: { 1: { wins: 0, losses: 0 }, 2: { wins: 0, losses: 0 } },
      result: null, // {word,isRealWord,winner,loser,defender,wordInfo}
    };

    const board = document.getElementById('board');
    const cards = document.getElementById('cards');
    const newRoundBtn = document.getElementById('newRound');
    const timerStatus = document.getElementById('timerStatus');
    const WIKTIONARY_API_BASE = 'https://en.wiktionary.org';
    const ENGLISH_API_BASE = 'https://api.dictionaryapi.dev/api/v2/entries/en';
    const langModeSelect = document.getElementById('langMode');
    const player1NameInput = document.getElementById('player1Name');
    const player2NameInput = document.getElementById('player2Name');
    const enableTimerInput = document.getElementById('enableTimer');
    const timerSecondsInput = document.getElementById('timerSeconds');
    const settings = {
      langMode: 'en',
      names: { 1: 'Player 1', 2: 'Player 2' },
      timerEnabled: false,
      timerSeconds: 10,
    };
    const SETTINGS_STORAGE_KEY = 'wordSandwichSettings';
    let turnTimerHandle = null;
    let turnTickerHandle = null;
    let turnTimerContext = '';
    let turnSecondsLeft = 0;

    const fragment = () => state.letters.map(x => x.char).join('');
    const sanitize = (v) => ((v || '').toLowerCase().match(/\p{L}/u) || [''])[0];

    function loadSettings() {
      try {
        const raw = localStorage.getItem(SETTINGS_STORAGE_KEY);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        const mode = parsed?.langMode;
        const p1 = (parsed?.names?.[1] || parsed?.names?.['1'] || '').toString().trim();
        const p2 = (parsed?.names?.[2] || parsed?.names?.['2'] || '').toString().trim();
        const timerEnabled = !!parsed?.timerEnabled;
        const timerSeconds = Number(parsed?.timerSeconds);
        if (mode === 'en' || mode === 'fr' || mode === 'en-fr') settings.langMode = mode;
        if (p1) settings.names[1] = p1;
        if (p2) settings.names[2] = p2;
        settings.timerEnabled = timerEnabled;
        if (Number.isFinite(timerSeconds) && timerSeconds >= 3 && timerSeconds <= 120) {
          settings.timerSeconds = Math.floor(timerSeconds);
        }
      } catch {
        // Ignore corrupted local settings.
      }
    }

    function saveSettings() {
      try {
        localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings));
      } catch {
        // Ignore storage write failures.
      }
    }

    function clearTurnTimer(resetContext = true) {
      if (turnTimerHandle) clearTimeout(turnTimerHandle);
      if (turnTickerHandle) clearInterval(turnTickerHandle);
      turnTimerHandle = null;
      turnTickerHandle = null;
      turnSecondsLeft = 0;
      if (resetContext) turnTimerContext = '';
    }

    function activeTimedPlayer() {
      if (!settings.timerEnabled || state.ended || state.validating) return null;
      if (state.letters.length === 0) return null;
      return state.mode === 'challenge' ? state.challengeDefender : state.turn;
    }

    function updateTimerStatus() {
      const player = activeTimedPlayer();
      if (!settings.timerEnabled || !player || turnSecondsLeft <= 0) {
        timerStatus.textContent = '';
        return;
      }
      timerStatus.textContent = `${playerName(player)}: ${turnSecondsLeft}s`;
    }

    function applyTimeoutLoss(slowPlayer) {
      if (state.ended || state.validating) return;
      const winner = slowPlayer === 1 ? 2 : 1;
      const loser = slowPlayer;
      state.ended = true;
      state.winner = winner;
      state.starter = winner;
      state.score[winner].wins += 1;
      state.score[loser].losses += 1;
      state.result = {
        reason: 'timeout',
        slowPlayer,
        winner,
        loser,
      };
      clearTurnTimer();
      render();
    }

    function startTurnTimer(player, contextKey) {
      clearTurnTimer(false);
      turnTimerContext = contextKey;
      turnSecondsLeft = settings.timerSeconds;
      updateTimerStatus();
      turnTickerHandle = setInterval(() => {
        turnSecondsLeft = Math.max(0, turnSecondsLeft - 1);
        updateTimerStatus();
      }, 1000);
      turnTimerHandle = setTimeout(() => applyTimeoutLoss(player), settings.timerSeconds * 1000);
    }

    function syncTurnTimer() {
      const player = activeTimedPlayer();
      if (!player) {
        clearTurnTimer();
        updateTimerStatus();
        return;
      }
      const contextKey = `${player}|${state.mode}|${state.letters.length === 0 ? 'start' : 'play'}`;
      if (turnTimerContext !== contextKey) startTurnTimer(player, contextKey);
      else updateTimerStatus();
    }

    function resetRound() {
      clearTurnTimer();
      state.letters = [];
      state.turn = state.starter;
      state.mode = 'normal';
      state.challengeBy = null;
      state.challengeDefender = null;
      state.ended = false;
      state.validating = false;
      state.winner = null;
      state.result = null;
      render();
    }

    function htmlToText(html) {
      const div = document.createElement('div');
      div.innerHTML = html || '';
      return (div.textContent || '').trim();
    }

    function getWiktionaryEntry(data, lang) {
      const expectedLanguage = lang === 'fr' ? 'French' : 'English';
      const entries = data?.[lang];
      if (!Array.isArray(entries) || entries.length === 0) return null;
      return entries.find((entry) => {
        if (entry?.language !== expectedLanguage) return false;
        if (entry?.partOfSpeech === 'Symbol') return false;
        return Array.isArray(entry.definitions) && entry.definitions.length > 0;
      });
    }

    function playerName(player) {
      return settings.names[player] || `Player ${player}`;
    }

    async function isEnglishWord(word) {
      try {
        const res = await fetch(`${ENGLISH_API_BASE}/${encodeURIComponent(word)}`);
        if (!res.ok) return { ok: false, info: null };
        const data = await res.json();
        if (!Array.isArray(data) || data.length === 0) return { ok: false, info: null };
        const first = data[0];
        const meaning = Array.isArray(first.meanings) ? first.meanings[0] : null;
        const def = meaning && Array.isArray(meaning.definitions) ? meaning.definitions[0] : null;
        return {
          ok: true,
          info: {
            language: 'English',
            partOfSpeech: meaning?.partOfSpeech || '',
            definition: def?.definition || '',
            source: 'DictionaryAPI',
          }
        };
      } catch {
        return { ok: false, info: null };
      }
    }

    async function isFrenchWord(word) {
      try {
        const res = await fetch(`${WIKTIONARY_API_BASE}/api/rest_v1/page/definition/${encodeURIComponent(word)}`);
        if (!res.ok) return { ok: false, info: null };
        const data = await res.json();
        const entry = getWiktionaryEntry(data, 'fr');
        if (!entry) return { ok: false, info: null };
        const firstDef = Array.isArray(entry.definitions) ? entry.definitions[0] : null;
        return {
          ok: true,
          info: {
            language: 'French',
            partOfSpeech: entry.partOfSpeech || '',
            definition: htmlToText(firstDef?.definition || ''),
            source: 'Wiktionary',
          }
        };
      } catch {
        return { ok: false, info: null };
      }
    }

    async function isRealWord(word) {
      if (settings.langMode === 'en') return isEnglishWord(word);
      if (settings.langMode === 'fr') return isFrenchWord(word);
      const [enResult, frResult] = await Promise.all([isEnglishWord(word), isFrenchWord(word)]);
      if (enResult.ok) return enResult;
      if (frResult.ok) return frResult;
      return { ok: false, info: null };
    }

    function appendLetter(side, player, letter) {
      if (!letter) return;
      if (side === 'front') state.letters.unshift({ char: letter, player });
      else state.letters.push({ char: letter, player });
    }

    function makeEntry({ cls, onLetter, placeholder = '+' }) {
      const input = document.createElement('input');
      input.className = `entry ${cls}`;
      input.maxLength = 1;
      input.placeholder = placeholder;
      input.addEventListener('input', (e) => {
        const letter = sanitize(e.target.value);
        e.target.value = '';
        if (letter) onLetter(letter);
      });
      return input;
    }

    function playerTitle(player) {
      if (!state.ended || !state.winner) return playerName(player);
      if (state.winner === player) return `${playerName(player)} Wins`;
      return `${playerName(player)} Loses`;
    }

    function playerActions(player) {
      if (state.ended) return [];
      if (state.letters.length === 0) {
        return player === state.turn ? ['Enter a letter.'] : [`Wait for ${playerName(state.turn)}.`];
      }
      if (state.mode === 'challenge') {
        return player === state.challengeDefender ? ['1. Finish word (2+ letters)', 'LOCK'] : [`Wait for ${playerName(state.challengeDefender)}.`];
      }
      return player === state.turn ? ['Add a letter', 'CHALLENGE'] : ['Wait your turn.'];
    }

    function renderCards() {
      cards.innerHTML = '';
      const activePlayer = state.letters.length === 0
        ? state.turn
        : (state.mode === 'challenge' ? state.challengeDefender : state.turn);
      const firstPlayer = state.ended && state.winner ? state.winner : activePlayer;
      const secondPlayer = firstPlayer === 1 ? 2 : 1;

      [firstPlayer, secondPlayer].forEach((p) => {
        const active = !state.ended && ((state.letters.length === 0 ? state.turn : (state.mode === 'challenge' ? state.challengeDefender : state.turn)) === p);
        const card = document.createElement('div');
        const focusClass = state.ended ? '' : (active ? 'active' : 'inactive');
        card.className = `card ${focusClass} ${state.ended ? (state.winner===p?'win':'lose') : ''}`;
        card.style.borderColor = p === 1 ? '#2563eb' : '#16a34a';
        const head = document.createElement('div');
        head.className = 'card-head';

        const title = document.createElement('div');
        title.className = 'title';
        title.style.color = p === 1 ? '#1d4ed8' : '#15803d';
        title.textContent = playerTitle(p);
        head.appendChild(title);

        const meta = document.createElement('div');
        meta.className = 'meta';
        meta.textContent = `W: ${state.score[p].wins}  L: ${state.score[p].losses}`;
        head.appendChild(meta);
        card.appendChild(head);

        const actions = playerActions(p);
        if (active && actions.length) {
          const ul = document.createElement('ul');
          actions.forEach((a) => {
            const li = document.createElement('li');
            if (a === 'CHALLENGE') {
              li.append('Or ');
              const btn = document.createElement('button');
              btn.className = 'btn warn';
              btn.textContent = 'Challenge';
              btn.onclick = () => {
                state.mode = 'challenge';
                state.challengeBy = state.turn;
                state.challengeDefender = state.turn === 1 ? 2 : 1;
                render();
              };
              li.appendChild(btn);
            } else if (a === 'LOCK') {
              li.append('2. Click ');
              const btn = document.createElement('button');
              btn.className = 'btn ok';
              btn.textContent = state.validating ? 'Validating...' : "It's a real word :)";
              const tooShort = fragment().length < 2;
              btn.disabled = state.validating || tooShort;
              btn.title = tooShort ? 'Add at least one more letter before locking.' : 'Lock and validate';
              btn.onclick = async () => {
                if (fragment().length < 2) return;
                state.validating = true;
                render();
                const word = fragment().toLowerCase();
                const verdict = await isRealWord(word);
                const ok = verdict.ok;
                const winner = ok ? state.challengeDefender : state.challengeBy;
                const loser = winner === 1 ? 2 : 1;
                state.validating = false;
                state.ended = true;
                state.winner = winner;
                state.starter = winner;
                state.score[winner].wins += 1;
                state.score[loser].losses += 1;
                state.result = {
                  reason: 'word',
                  word,
                  isRealWord: ok,
                  winner,
                  loser,
                  defender: state.challengeDefender,
                  wordInfo: verdict.info
                };
                render();
              };
              li.appendChild(btn);
            } else {
              li.textContent = a;
            }
            ul.appendChild(li);
          });
          card.appendChild(ul);
        }

        if (state.ended && state.result) {
          const msg = document.createElement('div');
          msg.style.marginTop = '8px';
          msg.style.fontWeight = '400';
          msg.style.fontSize = '11px';
          if (state.result.reason === 'timeout') {
            msg.style.color = p === state.result.winner ? '#166534' : '#9f1239';
            msg.innerHTML = p === state.result.winner
              ? `Player <strong>${playerName(state.result.slowPlayer)}</strong> is too slow, You eat their sandwich`
              : `You snooze, you lose!`;
          } else if (state.result.isRealWord) {
            msg.style.color = p === state.result.winner ? '#166534' : '#9f1239';
            msg.innerHTML = p === state.result.winner
              ? `<strong>"${state.result.word.toUpperCase()}"</strong> makes a delicious sandwich.`
              : `No sandwich for you.`;
          } else {
            msg.style.color = p === state.result.winner ? '#166534' : '#9f1239';
            msg.innerHTML = p === state.result.winner
              ? `<strong>${playerName(state.result.defender)}</strong> can't spell. You get the sandwich.`
              : `<strong>"${state.result.word.toUpperCase()}"</strong> isn't a word. No sandwich for you!`;
          }
          card.appendChild(msg);
        }

        if (
          state.ended &&
          state.result &&
          p === state.result.winner &&
          state.result.isRealWord &&
          state.result.wordInfo
        ) {
          const info = state.result.wordInfo;
          const infoBox = document.createElement('div');
          infoBox.className = 'word-info';

          const addRow = (label, value) => {
            const row = document.createElement('div');
            const labelEl = document.createElement('span');
            labelEl.className = 'label';
            labelEl.textContent = `${label}: `;
            row.appendChild(labelEl);
            row.appendChild(document.createTextNode(value || 'N/A'));
            infoBox.appendChild(row);
          };

          addRow('Definition', info.definition);
          addRow('Type', info.partOfSpeech);
          addRow('Language', info.language);
          addRow('Source', info.source);
          card.appendChild(infoBox);
        }

        cards.appendChild(card);
      });
    }

    function renderBoard() {
      board.innerHTML = '';
      const edgeClass = state.turn === 1 ? 'p1' : 'p2';
      const chClass = (state.challengeDefender || 1) === 1 ? 'p1' : 'p2';

      if (!state.ended && state.letters.length === 0) {
        board.appendChild(makeEntry({
          cls: edgeClass,
          placeholder: '?',
          onLetter: (letter) => {
            const starter = state.turn;
            state.letters = [{ char: letter, player: starter }];
            state.turn = starter === 1 ? 2 : 1;
            render();
          }
        }));
        return;
      }

      if (state.letters.length > 0) {
        if (!state.ended && state.mode === 'normal') {
          board.appendChild(makeEntry({ cls: edgeClass, onLetter: (letter) => {
            appendLetter('front', state.turn, letter);
            state.turn = state.turn === 1 ? 2 : 1;
            render();
          }}));
        }

        if (!state.ended && state.mode === 'challenge') {
          board.appendChild(makeEntry({ cls: chClass, onLetter: (letter) => {
            appendLetter('front', state.challengeDefender, letter);
            render();
          }}));
        }

        state.letters.forEach((c) => {
          const d = document.createElement('div');
          d.className = `cell ${c.player === 1 ? 'p1' : 'p2'}`;
          d.textContent = c.char;
          board.appendChild(d);
        });

        if (!state.ended && state.mode === 'normal') {
          board.appendChild(makeEntry({ cls: edgeClass, onLetter: (letter) => {
            appendLetter('back', state.turn, letter);
            state.turn = state.turn === 1 ? 2 : 1;
            render();
          }}));
        }

        if (!state.ended && state.mode === 'challenge') {
          board.appendChild(makeEntry({ cls: chClass, onLetter: (letter) => {
            appendLetter('back', state.challengeDefender, letter);
            render();
          }}));
        }
      }
    }

    function render() {
      renderBoard();
      renderCards();
      syncTurnTimer();
    }

    newRoundBtn.addEventListener('click', resetRound);
    langModeSelect.addEventListener('change', () => {
      settings.langMode = langModeSelect.value;
      saveSettings();
    });
    player1NameInput.addEventListener('input', () => {
      settings.names[1] = player1NameInput.value.trim() || 'Player 1';
      saveSettings();
      render();
    });
    player2NameInput.addEventListener('input', () => {
      settings.names[2] = player2NameInput.value.trim() || 'Player 2';
      saveSettings();
      render();
    });
    enableTimerInput.addEventListener('change', () => {
      settings.timerEnabled = enableTimerInput.checked;
      timerSecondsInput.disabled = !settings.timerEnabled;
      turnTimerContext = '';
      saveSettings();
      syncTurnTimer();
    });
    timerSecondsInput.addEventListener('change', () => {
      const next = Math.max(3, Math.min(120, Number(timerSecondsInput.value) || 10));
      settings.timerSeconds = Math.floor(next);
      timerSecondsInput.value = String(settings.timerSeconds);
      turnTimerContext = '';
      saveSettings();
      syncTurnTimer();
    });
    loadSettings();
    player1NameInput.value = settings.names[1];
    player2NameInput.value = settings.names[2];
    langModeSelect.value = settings.langMode;
    enableTimerInput.checked = settings.timerEnabled;
    timerSecondsInput.value = String(settings.timerSeconds);
    timerSecondsInput.disabled = !settings.timerEnabled;
    render();
  </script>
</body>
</html>


