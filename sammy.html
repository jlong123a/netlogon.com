<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Word Sandwich</title>
  <style>
    * { box-sizing: border-box; }
    :root {
      --p1: #93c5fd;
      --p2: #86efac;
      --muted: #64748b;
    }
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 8px;
      background: #f8fafc;
      color: #0f172a;
    }
    .wrap { max-width: 980px; margin: 0 auto; }
    h1 { margin: 0 0 8px; display: flex; align-items: center; justify-content: center; gap: 8px; font-size: 1.1rem; }
    .row { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; }
    .board {
      min-height: 42px;
      padding: 4px 0;
      width: 100%;
      gap: 0;
      justify-content: center;
      overflow-x: auto;
      flex-wrap: nowrap;
      -webkit-overflow-scrolling: touch;
    }
    .board > * { flex: 0 0 auto; }
    .cell, .entry {
      width: 26px;
      height: 26px;
      border-radius: 5px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: .75rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: .02em;
    }
    .cell { color: #0f172a; border: 1px solid rgba(15, 23, 42, 0.22); }
    .p1 { background: var(--p1); }
    .p2 { background: var(--p2); }
    .entry {
      border: 2px dashed #94a3b8;
      outline: none;
      background: #ffffff;
      text-align: center;
      font-size: 16px;
      font-weight: 500;
    }
    .entry.p1 { border-color: var(--p1); color: var(--p1); }
    .entry.p2 { border-color: var(--p2); color: var(--p2); }
    .inline-word {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      flex-wrap: nowrap;
      padding-top: 4px;
    }
    .inline-word .entry { width: 28px; height: 28px; }
    .inline-word .cell { width: 28px; height: 28px; }
    .result-word {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-top: 4px;
      margin-bottom: 4px;
    }
    .result-word .cell {
      width: 28px;
      height: 28px;
      border-radius: 6px;
      font-size: .78rem;
    }
    .btn {
      border: 1px solid #334155;
      background: white;
      color: #334155;
      padding: 4px 8px;
      min-height: 30px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
    }
    .btn.warn { border-color: #7c2d12; background: #fff7ed; color: #9a3412; }
    .btn.ok { border-color: #14532d; background: #ecfdf5; color: #166534; }
    .btn:disabled { opacity: .6; cursor: not-allowed; }
    .cards {
      margin-top: 8px;
      display: grid;
      gap: 6px;
      width: 100%;
      max-width: 720px;
      grid-template-columns: 1fr;
    }
    .card {
      border: 1px solid #cbd5e1;
      border-radius: 8px;
      padding: 8px;
      min-width: 0;
      width: 100%;
      background: #f8fafc;
      transition: .12s ease all;
    }
    .card.active { opacity: 1; transform: scale(1); }
    .card.inactive { opacity: .7; transform: scale(.99); }
    .card.win { background: #ecfdf5; }
    .card.lose { background: #fff1f2; }
    .card.draw { background: #e2e8f0; }
    .history {
      margin-top: 12px;
      padding: 10px;
      border: 1px solid #cbd5e1;
      border-radius: 8px;
      background: #ffffff;
      max-width: 720px;
      font-size: 12px;
      color: #0f172a;
    }
    .history h3 {
      margin: 0 0 6px;
      font-size: 12px;
      font-weight: 700;
      color: #0f172a;
    }
    .history-current {
      margin-bottom: 8px;
      padding: 6px 8px;
      border: 1px dashed #cbd5e1;
      border-radius: 6px;
      background: #f8fafc;
      font-size: 12px;
      color: #0f172a;
    }
    .history-current .label { font-weight: 700; color: #475569; margin-right: 6px; }
    .history-final {
      margin-top: 8px;
      padding: 8px 10px;
      border: 1px solid #cbd5e1;
      border-radius: 8px;
      background: #eef2f7;
      font-size: 12px;
      color: #0f172a;
      font-weight: 600;
    }
    .history-sub { margin-left: 12px; font-weight: 500; color: #334155; }
    .history ol {
      margin: 0;
      padding-left: 18px;
    }
    .history li { margin-bottom: 3px; line-height: 1.35; }
    .card-head {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 6px;
    }
    .title { font-weight: 700; margin-bottom: 0; font-size: 13px; }
    .meta { color: #334155; font-size: 11px; white-space: nowrap; }
    ul { margin: 6px 0 0; padding-left: 14px; font-size: 11px; }
    li { margin-bottom: 2px; }
    .card .btn {
      width: auto;
      min-height: 24px;
      padding: 2px 6px;
      font-size: 11px;
    }
    .word-info {
      margin-top: 6px;
      padding: 6px;
      border: 1px solid #cbd5e1;
      border-radius: 6px;
      background: #ffffff;
      font-size: 11px;
      line-height: 1.3;
      color: #0f172a;
    }
    .word-info .label {
      color: #475569;
      font-weight: 600;
    }
    .settings {
      margin-top: 8px;
      border: 1px solid #cbd5e1;
      border-radius: 8px;
      background: #ffffff;
      padding: 0;
      max-width: 720px;
      overflow: hidden;
    }
    .settings summary {
      cursor: pointer;
      font-size: 12px;
      font-weight: 700;
      color: #0f172a;
      list-style: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      background: #eef2f7;
      border-bottom: 1px solid #cbd5e1;
    }
    .settings summary::-webkit-details-marker { display: none; }
    .settings summary::after {
      content: 'â–¾';
      font-size: 12px;
      color: #475569;
    }
    .settings:not([open]) summary::after { content: 'â–¸'; }
    .settings-grid {
      margin-top: 0;
      display: grid;
      gap: 8px;
      padding: 8px;
    }
    .field label {
      display: block;
      font-size: 11px;
      color: #475569;
      margin-bottom: 2px;
    }
    .field input, .field select {
      width: 100%;
      min-height: 26px;
      border: 1px solid #cbd5e1;
      border-radius: 6px;
      padding: 3px 6px;
      font-size: 12px;
      background: #fff;
      color: #0f172a;
    }
    .action-timer {
      color: #475569;
      font-size: 11px;
      margin-left: 4px;
    }
    .timer-fields {
      display: grid;
      grid-template-columns: 1fr 110px;
      gap: 8px;
      align-items: end;
    }
    .checkbox-row {
      display: flex;
      align-items: center;
      gap: 6px;
      min-height: 26px;
      font-size: 12px;
      color: #0f172a;
      font-weight: 400;
    }
    .checkbox-row input[type="checkbox"] {
      width: auto;
      min-height: 0;
      margin: 0;
    }

    @media (max-width: 640px) {
      body { padding: 6px; }
      h1 { font-size: 1rem; line-height: 1.15; margin-bottom: 6px; }
      .row { gap: 6px; }
      .board { gap: 0; }
      .timer-fields { grid-template-columns: 1fr 92px; }
      .cell, .entry {
        width: 24px;
        height: 24px;
        border-radius: 4px;
        font-size: .7rem;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1><span style="font-size:1.5em">ðŸ¥–</span> Word Sandwich<span style="font-size:1.5em">ðŸ¥–</span></h1>

    <div class="cards" id="cards"></div>
    <div class="history" id="history"></div>

    <details class="settings" open>
      <summary>Settings</summary>
      <div class="settings-grid">
        <div class="field">
          <label for="langMode">Language</label>
          <select id="langMode">
            <option value="en" selected>English</option>
            <option value="fr">French</option>
            <option value="en-fr">English + French</option>
          </select>
        </div>
        <div class="field">
          <label for="player1Name">Player 1 Name</label>
          <input id="player1Name" type="text" maxlength="24" placeholder="Player 1" />
        </div>
        <div class="field">
          <label for="player2Name">Player 2 Name</label>
          <input id="player2Name" type="text" maxlength="24" placeholder="Player 2" />
        </div>
        <div class="timer-fields">
          <div class="field">
            <label for="enableTimer">Turn Timer</label>
            <div class="checkbox-row">
              <input id="enableTimer" type="checkbox" />
              <span>Enable timer</span>
            </div>
          </div>
          <div class="field">
            <label for="timerSeconds">Seconds</label>
            <input id="timerSeconds" type="number" min="3" max="120" step="1" value="30" />
          </div>
        </div>
      </div>
    </details>
  </div>

  <script>
    const MIN_WORD_LENGTH = 3;

    const state = {
      letters: [], // {char, player}
      turn: 1,
      mode: 'normal', // normal | challenge | double
      challengeBy: null,
      challengeDefender: null,
      ended: false,
      validating: false,
      winner: null,
      starter: 1,
      score: { 1: { wins: 0, losses: 0 }, 2: { wins: 0, losses: 0 } },
      result: null, // {word,isRealWord,winner,loser,defender,wordInfo}
      autoChallengeTriggered: false,
      autoLockTriggered: false,
      history: [], // newest first
      lastMainPlayer: null,
      doubleOrNothing: null, // {winner,loser,defender,baseWord,trying,message,validating}
    };

    const board = document.getElementById('board');
    const cards = document.getElementById('cards');
    const historyEl = document.getElementById('history');
    const WIKTIONARY_API_BASE = 'https://en.wiktionary.org';
    const ENGLISH_API_BASE = 'https://api.dictionaryapi.dev/api/v2/entries/en';
    const langModeSelect = document.getElementById('langMode');
    const player1NameInput = document.getElementById('player1Name');
    const player2NameInput = document.getElementById('player2Name');
    const enableTimerInput = document.getElementById('enableTimer');
    const timerSecondsInput = document.getElementById('timerSeconds');
    const settings = {
      langMode: 'en',
      names: { 1: 'Player 1', 2: 'Player 2' },
      timerEnabled: false,
      timerSeconds: 30,
    };
    const SETTINGS_STORAGE_KEY = 'wordSandwichSettings';
    let turnTimerHandle = null;
    let turnTickerHandle = null;
    let turnTimerContext = '';
    let turnSecondsLeft = 0;

    const fragment = () => state.letters.map(x => x.char).join('');
    const sanitize = (v) => ((v || '').toLowerCase().match(/\p{L}/u) || [''])[0];

    function loadSettings() {
      try {
        const raw = localStorage.getItem(SETTINGS_STORAGE_KEY);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        const mode = parsed?.langMode;
        const p1 = (parsed?.names?.[1] || parsed?.names?.['1'] || '').toString().trim();
        const p2 = (parsed?.names?.[2] || parsed?.names?.['2'] || '').toString().trim();
        const timerEnabled = !!parsed?.timerEnabled;
        const timerSeconds = Number(parsed?.timerSeconds);
        if (mode === 'en' || mode === 'fr' || mode === 'en-fr') settings.langMode = mode;
        if (p1) settings.names[1] = p1;
        if (p2) settings.names[2] = p2;
        settings.timerEnabled = timerEnabled;
        if (Number.isFinite(timerSeconds) && timerSeconds >= 3 && timerSeconds <= 120) {
          settings.timerSeconds = Math.floor(timerSeconds);
        }
      } catch {
        // Ignore corrupted local settings.
      }
    }

    function saveSettings() {
      try {
        localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings));
      } catch {
        // Ignore storage write failures.
      }
    }

    function clearTurnTimer(resetContext = true) {
      if (turnTimerHandle) clearTimeout(turnTimerHandle);
      if (turnTickerHandle) clearInterval(turnTickerHandle);
      turnTimerHandle = null;
      turnTickerHandle = null;
      turnSecondsLeft = 0;
      if (resetContext) turnTimerContext = '';
    }

    function activeTimedPlayer() {
      if (!settings.timerEnabled || state.ended || state.validating) return null;
      if (state.mode === 'double') return null;
      if (state.letters.length === 0) return null; // no timer on the very first turn before any letter is placed
      return state.mode === 'challenge' ? state.challengeDefender : state.turn;
    }

    function updateTimerStatus() {
      updateActionTimers();
      renderHistory();
    }

    function applyTimeoutLoss(slowPlayer) {
      if (state.ended || state.validating) return;
      const lettersCount = fragment().length;
      const hasEnoughLetters = lettersCount >= MIN_WORD_LENGTH;
      const opponent = slowPlayer === 1 ? 2 : 1;
      const autoOn = settings.timerEnabled;

      // Normal mode: auto-challenge if possible
      if (state.mode === 'normal' && autoOn) {
        if (hasEnoughLetters) {
          logAutoChallenge(slowPlayer);
          logTimeout(slowPlayer);
          state.mode = 'challenge';
          state.challengeBy = slowPlayer;
          state.challengeDefender = opponent;
          state.autoChallengeTriggered = true;
          state.autoLockTriggered = false;
          clearTurnTimer(false);
          render();
          return;
        }
        // Cannot challenge due to length -> draw
        logTimeout(slowPlayer);
        state.ended = true;
        state.winner = null;
        state.result = { reason: 'draw', cause: 'timeout-short', slowPlayer };
        clearTurnTimer();
        render();
        return;
      }

      // Challenge mode: defender times out -> treat as lock click
      if (state.mode === 'challenge' && autoOn && slowPlayer === state.challengeDefender) {
        const autoChain = state.autoChallengeTriggered && !state.autoLockTriggered;
        if (!hasEnoughLetters) {
          logTimeout(slowPlayer);
          state.ended = true;
          state.winner = null;
          state.result = { reason: 'draw', cause: 'timeout-short', slowPlayer };
          clearTurnTimer();
          render();
          return;
        }
        if (autoChain) {
          state.autoLockTriggered = true;
          logAutoCheck(slowPlayer);
          logTimeout(slowPlayer);
          state.ended = true;
          state.winner = null;
          state.result = { reason: 'draw', cause: 'auto-chain', slowPlayer };
          clearTurnTimer();
          render();
          return;
        }
        // Manual challenge, auto lock: validate word
        state.autoLockTriggered = true;
        logAutoCheck(slowPlayer);
        logTimeout(slowPlayer);
        (async () => {
          state.validating = true;
          render();
          const word = fragment().toLowerCase();
          const verdict = await isRealWord(word);
          const ok = verdict.ok;
          const winner = ok ? state.challengeDefender : state.challengeBy;
          const loser = winner === 1 ? 2 : 1;
          state.validating = false;
          if (!ok) {
            enterDoubleOrNothing({
              winner,
              loser,
              defender: state.challengeDefender,
              baseWord: word,
            });
            return;
          }
          finalizeRound({
            winner,
            loser,
            points: 1,
            result: {
              reason: 'word',
              word,
              isRealWord: true,
              winner,
              loser,
              defender: state.challengeDefender,
              wordInfo: verdict.info,
              autoLock: true,
            }
          });
        })();
        return;
      }

      // Fallbacks (no auto or other cases)
      if (!hasEnoughLetters) {
        logTimeout(slowPlayer);
        state.ended = true;
        state.winner = null;
        state.result = { reason: 'draw', cause: 'timeout-short', slowPlayer };
        clearTurnTimer();
        render();
        return;
      }

      const winner = slowPlayer === 1 ? 2 : 1;
      const loser = slowPlayer;
      logTimeout(slowPlayer);
      state.ended = true;
      state.winner = winner;
      state.starter = winner;
      state.score[winner].wins += 1;
      state.score[loser].losses += 1;
      state.result = {
        reason: 'timeout',
        slowPlayer,
        winner,
        loser,
      };
      clearTurnTimer();
      render();
    }

    function startTurnTimer(player, contextKey) {
      clearTurnTimer(false);
      turnTimerContext = contextKey;
      turnSecondsLeft = settings.timerSeconds;
      updateTimerStatus();
      turnTickerHandle = setInterval(() => {
        turnSecondsLeft = Math.max(0, turnSecondsLeft - 1);
        updateTimerStatus();
      }, 1000);
      turnTimerHandle = setTimeout(() => applyTimeoutLoss(player), settings.timerSeconds * 1000);
    }

    function syncTurnTimer() {
      const player = activeTimedPlayer();
      if (!player) {
        clearTurnTimer();
        updateTimerStatus();
        return;
      }
      const contextKey = `${player}|${state.mode}|${state.letters.length === 0 ? 'start' : 'play'}`;
      if (turnTimerContext !== contextKey) startTurnTimer(player, contextKey);
      else updateTimerStatus();
    }

    function resetRound() {
      clearTurnTimer();
      state.letters = [];
      state.turn = state.starter;
      state.mode = 'normal';
      state.challengeBy = null;
      state.challengeDefender = null;
      state.ended = false;
      state.validating = false;
      state.winner = null;
      state.result = null;
      state.history = [];
      state.lastMainPlayer = null;
      state.doubleOrNothing = null;
      clearAutoFlags();
      render();
    }

    function finalizeRound({ winner, loser, result, points = 1 }) {
      state.ended = true;
      state.mode = 'normal';
      state.winner = winner;
      state.starter = winner;
      state.score[winner].wins += points;
      state.score[loser].losses += 1;
      state.result = result;
      state.doubleOrNothing = null;
      clearTurnTimer();
      render();
    }

    function enterDoubleOrNothing({ winner, loser, defender, baseWord }) {
      state.ended = false;
      state.mode = 'double';
      state.winner = winner;
      state.doubleOrNothing = {
        winner,
        loser,
        defender,
        baseWord,
        trying: false,
        message: '',
        validating: false,
      };
      clearTurnTimer();
      render();
    }

    function htmlToText(html) {
      const div = document.createElement('div');
      div.innerHTML = html || '';
      return (div.textContent || '').trim();
    }

    function getWiktionaryEntry(data, lang) {
      const expectedLanguage = lang === 'fr' ? 'French' : 'English';
      const entries = data?.[lang];
      if (!Array.isArray(entries) || entries.length === 0) return null;
      return entries.find((entry) => {
        if (entry?.language !== expectedLanguage) return false;
        if (entry?.partOfSpeech === 'Symbol') return false;
        return Array.isArray(entry.definitions) && entry.definitions.length > 0;
      });
    }

    function playerName(player) {
      return settings.names[player] || `Player ${player}`;
    }

    function createActionTimerSpan(player) {
      const span = document.createElement('span');
      span.className = 'action-timer';
      span.dataset.player = String(player);
      return span;
    }

    function updateActionTimers() {
      const timedPlayer = activeTimedPlayer();
      const timeText = (settings.timerEnabled && turnSecondsLeft > 0) ? `${turnSecondsLeft}s` : '';
      document.querySelectorAll('.action-timer').forEach((el) => {
        const player = Number(el.dataset.player);
        el.textContent = timedPlayer === player ? timeText : '';
      });
    }

    async function isEnglishWord(word) {
      try {
        const res = await fetch(`${ENGLISH_API_BASE}/${encodeURIComponent(word)}`);
        if (!res.ok) return { ok: false, info: null };
        const data = await res.json();
        if (!Array.isArray(data) || data.length === 0) return { ok: false, info: null };
        const first = data[0];
        const meaning = Array.isArray(first.meanings) ? first.meanings[0] : null;
        const def = meaning && Array.isArray(meaning.definitions) ? meaning.definitions[0] : null;
        return {
          ok: true,
          info: {
            language: 'English',
            partOfSpeech: meaning?.partOfSpeech || '',
            definition: def?.definition || '',
            source: 'DictionaryAPI',
          }
        };
      } catch {
        return { ok: false, info: null };
      }
    }

    async function isFrenchWord(word) {
      try {
        const res = await fetch(`${WIKTIONARY_API_BASE}/api/rest_v1/page/definition/${encodeURIComponent(word)}`);
        if (!res.ok) return { ok: false, info: null };
        const data = await res.json();
        const entry = getWiktionaryEntry(data, 'fr');
        if (!entry) return { ok: false, info: null };
        const firstDef = Array.isArray(entry.definitions) ? entry.definitions[0] : null;
        return {
          ok: true,
          info: {
            language: 'French',
            partOfSpeech: entry.partOfSpeech || '',
            definition: htmlToText(firstDef?.definition || ''),
            source: 'Wiktionary',
          }
        };
      } catch {
        return { ok: false, info: null };
      }
    }

    async function isRealWord(word) {
      if (settings.langMode === 'en') return isEnglishWord(word);
      if (settings.langMode === 'fr') return isFrenchWord(word);
      const [enResult, frResult] = await Promise.all([isEnglishWord(word), isFrenchWord(word)]);
      if (enResult.ok) return enResult;
      if (frResult.ok) return frResult;
      return { ok: false, info: null };
    }

    function clearAutoFlags() {
      state.autoChallengeTriggered = false;
      state.autoLockTriggered = false;
    }

    function formatFragmentWithHighlight(highlightIndex = null) {
      const chars = fragment().split('').map((c, i) => {
        const upper = c.toUpperCase();
        return i === highlightIndex ? `<strong>${upper}</strong>` : upper;
      });
      return `"${chars.join('')}"`;
    }

    function pushHistory(entry) {
      state.history.unshift(entry);
      if (state.history.length > 50) state.history.pop();
    }

    function logCheck(player, auto = false) {
      const word = fragment();
      const wordText = word ? `"${word.toUpperCase()}"` : '';
      const attachAsSub = state.lastMainPlayer === player;
      pushHistory({
        text: `${playerName(player)} ${auto ? 'auto-checks' : 'checks'} ${wordText}`.trim(),
        fragment: formatFragmentWithHighlight(null),
        sub: attachAsSub,
        player,
      });
      if (!attachAsSub) state.lastMainPlayer = player;
    }

    function logTimeout(player) {
      pushHistory({
        text: `${playerName(player)}'s time ran out`,
        fragment: null,
        sub: false,
        player,
      });
      state.lastMainPlayer = player;
    }

    function logAutoChallenge(player) {
      const word = fragment();
      const wordText = word ? ` "${word.toUpperCase()}"` : '';
      pushHistory({
        text: `${playerName(player)} auto-challenges${wordText}`,
        fragment: null,
        sub: true,
        player,
      });
    }

    function logAutoCheck(player) {
      const word = fragment();
      const wordText = word ? ` "${word.toUpperCase()}"` : '';
      pushHistory({
        text: `${playerName(player)} auto-checks${wordText}`,
        fragment: null,
        sub: true,
        player,
      });
    }

    function logAdd(player, letter, side, intent = 'add') {
      const frag = fragment();
      if (!frag.length) return;
      let idx = side === 'front' ? 0 : frag.length - 1;
      if (intent === 'start') idx = 0;
      const verb = intent === 'start' ? 'starts with' : 'adds';
      const attachAsSub = state.mode === 'challenge' && state.challengeDefender === player && state.lastMainPlayer === player;
      const entry = {
        text: `${playerName(player)} ${verb} ${letter.toUpperCase()}`,
        fragment: formatFragmentWithHighlight(idx),
        sub: attachAsSub,
        player,
      };
      pushHistory(entry);
      if (!attachAsSub) state.lastMainPlayer = player;
    }

    function logChallenge(player, auto = false) {
      pushHistory({
        text: `${playerName(player)} challenges${auto ? ' (auto)' : ''}`,
        fragment: formatFragmentWithHighlight(null),
        sub: false,
        player,
      });
      state.lastMainPlayer = player;
    }

    function appendLetter(side, player, letter) {
      if (!letter) return;
      clearAutoFlags();
      if (side === 'front') state.letters.unshift({ char: letter, player });
      else state.letters.push({ char: letter, player });
    }

    function addLetterAndLog(side, player, letter, intent = 'add') {
      appendLetter(side, player, letter);
      logAdd(player, letter, side, intent);
    }

    function makeEntry({ cls, onLetter, placeholder = '+' }) {
      const input = document.createElement('input');
      input.className = `entry ${cls}`;
      input.maxLength = 1;
      input.placeholder = placeholder;
      input.addEventListener('input', (e) => {
        const letter = sanitize(e.target.value);
        e.target.value = '';
        if (letter) onLetter(letter);
      });
      return input;
    }

    function inlineWordRow({ front, back }) {
      const row = document.createElement('div');
      row.className = 'inline-word';
      if (front) row.appendChild(front);
      if (state.letters.length > 0) {
        state.letters.forEach((c) => {
          const d = document.createElement('div');
          d.className = `cell ${c.player === 1 ? 'p1' : 'p2'}`;
          d.textContent = c.char;
          row.appendChild(d);
        });
      }
      if (back) row.appendChild(back);
      return row;
    }

    function resultWordRow() {
      const row = document.createElement('div');
      row.className = 'result-word';
      state.letters.forEach((c) => {
        const d = document.createElement('div');
        d.className = `cell ${c.player === 1 ? 'p1' : 'p2'}`;
        d.textContent = c.char;
        row.appendChild(d);
      });
      return row;
    }

    function playerTitle(player) {
      if (state.mode === 'double' && state.doubleOrNothing) {
        if (player === state.doubleOrNothing.winner) return `${playerName(player)} Wins`;
        if (player === state.doubleOrNothing.loser) return `${playerName(player)} Loses`;
      }
      if (!state.ended) return playerName(player);
      if (state.winner === null) return `${playerName(player)} Draw`;
      if (state.winner === player) return `${playerName(player)} Wins`;
      return `${playerName(player)} Loses`;
    }

    function playerActions(player) {
      if (state.ended) return [];
      if (state.mode === 'double' && state.doubleOrNothing) {
        if (player !== state.doubleOrNothing.winner) {
          return [{ type: 'text', text: `Wait for ${playerName(state.doubleOrNothing.winner)}.` }];
        }
        if (!state.doubleOrNothing.trying) {
          return [{ type: 'double_take' }, { type: 'double_try' }, { type: 'double_word_preview' }];
        }
        return [{ type: 'double_take' }, { type: 'double_add' }, { type: 'double_check' }];
      }
      const waitTurn = [{ type: 'text', text: `Wait for ${playerName(state.mode === 'challenge' ? state.challengeDefender : state.turn)}.` }];
      if (state.letters.length === 0) {
        return player === state.turn ? [{ type: 'add' }] : waitTurn;
      }
      if (state.mode === 'challenge') {
        return player === state.challengeDefender ? [{ type: 'finish' }, { type: 'lock' }] : waitTurn;
      }
      const canChallenge = fragment().length >= MIN_WORD_LENGTH;
      const actions = [{ type: 'add' }];
      if (canChallenge) actions.push({ type: 'challenge' });
      return player === state.turn ? actions : [{ type: 'text', text: 'Wait your turn.' }];
    }

    function renderCards() {
      cards.innerHTML = '';
      const activePlayer = state.mode === 'double' && state.doubleOrNothing
        ? state.doubleOrNothing.winner
        : (state.letters.length === 0
          ? state.turn
          : (state.mode === 'challenge' ? state.challengeDefender : state.turn));
      const firstPlayer = state.ended && state.winner ? state.winner : activePlayer;
      const secondPlayer = firstPlayer === 1 ? 2 : 1;

      [firstPlayer, secondPlayer].forEach((p) => {
        const actingPlayer = state.mode === 'double' && state.doubleOrNothing
          ? state.doubleOrNothing.winner
          : (state.letters.length === 0 ? state.turn : (state.mode === 'challenge' ? state.challengeDefender : state.turn));
        const active = !state.ended && (actingPlayer === p);
        const card = document.createElement('div');
        const focusClass = state.ended ? '' : (active ? 'active' : 'inactive');
        const outcomeClass = state.ended ? (state.winner === null ? 'draw' : (state.winner===p?'win':'lose')) : '';
        card.className = `card ${focusClass} ${outcomeClass}`;
        card.style.borderColor = p === 1 ? '#2563eb' : '#16a34a';
        const head = document.createElement('div');
        head.className = 'card-head';

        const title = document.createElement('div');
        title.className = 'title';
        title.style.color = p === 1 ? '#1d4ed8' : '#15803d';
        title.textContent = playerTitle(p);
        head.appendChild(title);

        const meta = document.createElement('div');
        meta.className = 'meta';
        meta.textContent = `Points: ${state.score[p].wins}`;
        head.appendChild(meta);
        card.appendChild(head);

        const actions = playerActions(p);
        if (active && actions.length) {
          const ul = document.createElement('ul');
          actions.forEach((action, idx) => {
            const li = document.createElement('li');
            if (action.type === 'text') {
              li.textContent = action.text;
            } else if (action.type === 'double_take') {
              const btn = document.createElement('button');
              btn.className = 'btn warn';
              btn.textContent = 'Take the win';
              btn.onclick = () => {
                const d = state.doubleOrNothing;
                if (!d) return;
                finalizeRound({
                  winner: d.winner,
                  loser: d.loser,
                  points: 1,
                  result: {
                    reason: 'word',
                    word: d.baseWord,
                    isRealWord: false,
                    winner: d.winner,
                    loser: d.loser,
                    defender: d.defender,
                    wordInfo: null,
                    doubleResolved: 'take',
                  }
                });
              };
              li.appendChild(btn);
              li.append(' (1 point)');
            } else if (action.type === 'double_try') {
              const btn = document.createElement('button');
              btn.className = 'btn ok';
              btn.textContent = 'Try to finish the word';
              btn.onclick = () => {
                if (!state.doubleOrNothing) return;
                state.doubleOrNothing.trying = true;
                state.doubleOrNothing.message = '';
                render();
              };
              li.appendChild(btn);
              li.append(' (2 points)');
            } else if (action.type === 'double_word_preview') {
              li.appendChild(resultWordRow());
            } else if (action.type === 'double_add') {
              li.append(document.createTextNode('Add letters to finish: '));
              const d = state.doubleOrNothing;
              const front = makeEntry({ cls: d.winner === 1 ? 'p1' : 'p2', placeholder: '?', onLetter: (letter) => {
                addLetterAndLog('front', d.winner, letter, 'add');
                if (state.doubleOrNothing) state.doubleOrNothing.message = '';
                render();
              }});
              const back = makeEntry({ cls: d.winner === 1 ? 'p1' : 'p2', placeholder: '?', onLetter: (letter) => {
                addLetterAndLog('back', d.winner, letter, 'add');
                if (state.doubleOrNothing) state.doubleOrNothing.message = '';
                render();
              }});
              const row = inlineWordRow({ front, back });
              row.style.display = 'flex';
              li.appendChild(row);
            } else if (action.type === 'double_check') {
              li.append('Check for 2 points ');
              const btn = document.createElement('button');
              btn.className = 'btn ok';
              const d = state.doubleOrNothing;
              btn.textContent = d && d.validating ? 'Validating...' : 'Check word';
              btn.disabled = (d && d.validating) || fragment().length < MIN_WORD_LENGTH;
              btn.onclick = async () => {
                if (!state.doubleOrNothing || fragment().length < MIN_WORD_LENGTH) return;
                const d2 = state.doubleOrNothing;
                d2.validating = true;
                d2.message = '';
                render();
                const word = fragment().toLowerCase();
                const verdict = await isRealWord(word);
                d2.validating = false;
                if (!verdict.ok) {
                  d2.message = `"${word.toUpperCase()}" isn't a real word yet.`;
                  render();
                  return;
                }
                logCheck(d2.winner, false);
                finalizeRound({
                  winner: d2.winner,
                  loser: d2.loser,
                  points: 2,
                  result: {
                    reason: 'word',
                    word,
                    isRealWord: true,
                    winner: d2.winner,
                    loser: d2.loser,
                    defender: d2.defender,
                    wordInfo: verdict.info,
                    doubleResolved: 'finish',
                  }
                });
              };
              li.appendChild(btn);
            } else if (action.type === 'challenge') {
              li.append('Or ');
              const btn = document.createElement('button');
              btn.className = 'btn warn';
              btn.textContent = 'Challenge';
              btn.onclick = () => {
                clearAutoFlags();
                state.mode = 'challenge';
                state.challengeBy = state.turn;
                state.challengeDefender = state.turn === 1 ? 2 : 1;
                logChallenge(state.turn, false);
                render();
              };
              li.appendChild(btn);
            } else if (action.type === 'lock') {
              li.append('2. Click ');
              const btn = document.createElement('button');
              btn.className = 'btn ok';
              btn.textContent = state.validating ? 'Validating...' : "Check word";
              const tooShort = fragment().length < MIN_WORD_LENGTH;
              btn.disabled = state.validating || tooShort;
              btn.title = tooShort ? `Need at least ${MIN_WORD_LENGTH} letters before locking.` : 'Lock and validate';
              btn.onclick = async () => {
                if (fragment().length < MIN_WORD_LENGTH) return;
                clearAutoFlags();
                logCheck(state.challengeDefender, false);
                state.validating = true;
                render();
                const word = fragment().toLowerCase();
                const verdict = await isRealWord(word);
                const ok = verdict.ok;
                const winner = ok ? state.challengeDefender : state.challengeBy;
                const loser = winner === 1 ? 2 : 1;
                state.validating = false;
                if (!ok) {
                  enterDoubleOrNothing({
                    winner,
                    loser,
                    defender: state.challengeDefender,
                    baseWord: word,
                  });
                  return;
                }
                finalizeRound({
                  winner,
                  loser,
                  points: 1,
                  result: {
                    reason: 'word',
                    word,
                    isRealWord: true,
                    winner,
                    loser,
                    defender: state.challengeDefender,
                    wordInfo: verdict.info
                  }
                });
              };
              li.appendChild(btn);
            } else if (action.type === 'add') {
              li.append(document.createTextNode('Add a letter: '));
              li.appendChild(createActionTimerSpan(p));
              if (state.letters.length === 0) {
                const entry = makeEntry({ cls: p === 1 ? 'p1' : 'p2', placeholder: '?', onLetter: (letter) => {
                  const starter = state.turn;
                  addLetterAndLog('front', starter, letter, 'start');
                  state.turn = starter === 1 ? 2 : 1;
                  render();
                }});
                const row = inlineWordRow({ front: entry });
                row.style.display = 'flex';
                li.appendChild(row);
              } else {
                const front = makeEntry({ cls: p === 1 ? 'p1' : 'p2', placeholder: '?', onLetter: (letter) => {
                  addLetterAndLog('front', p, letter, 'add');
                  state.turn = p === 1 ? 2 : 1;
                  render();
                }});
                const back = makeEntry({ cls: p === 1 ? 'p1' : 'p2', placeholder: '?', onLetter: (letter) => {
                  addLetterAndLog('back', p, letter, 'add');
                  state.turn = p === 1 ? 2 : 1;
                  render();
                }});
                const row = inlineWordRow({ front, back });
                row.style.display = 'flex';
                li.appendChild(row);
              }
              if (state.letters.length < MIN_WORD_LENGTH) {
                const note = document.createElement('div');
                note.style.fontSize = '10px';
                note.style.marginTop = '4px';
                note.innerHTML = '<strong>Note:</strong> minimum 3 letters before you can challenge';
                li.appendChild(note);
              }
            } else if (action.type === 'finish') {
              li.append(document.createTextNode('1. Finish the word: '));
              li.appendChild(createActionTimerSpan(state.challengeDefender));
              const front = makeEntry({ cls: state.challengeDefender === 1 ? 'p1' : 'p2', placeholder: '?', onLetter: (letter) => {
                addLetterAndLog('front', state.challengeDefender, letter, 'add');
                render();
              }});
              const back = makeEntry({ cls: state.challengeDefender === 1 ? 'p1' : 'p2', placeholder: '?', onLetter: (letter) => {
                addLetterAndLog('back', state.challengeDefender, letter, 'add');
                render();
              }});
              const row = inlineWordRow({ front, back });
              row.style.display = 'flex';
              li.appendChild(row);
            }
            ul.appendChild(li);
          });
          card.appendChild(ul);
        }

        if (state.mode === 'double' && state.doubleOrNothing && p === state.doubleOrNothing.winner) {
          const doubleMsg = document.createElement('div');
          doubleMsg.style.marginTop = '6px';
          doubleMsg.style.fontSize = '12px';
          doubleMsg.style.fontWeight = '600';
          doubleMsg.style.color = '#166534';
          doubleMsg.textContent = `${playerName(state.doubleOrNothing.defender)} can't spell.`;
          card.appendChild(doubleMsg);

          if (state.doubleOrNothing.message) {
            const msg = document.createElement('div');
            msg.style.marginTop = '4px';
            msg.style.fontSize = '11px';
            msg.style.color = '#9f1239';
            msg.textContent = state.doubleOrNothing.message;
            card.appendChild(msg);
          }
        }

        if (state.ended && state.result) {
          const showResultWord =
            state.result.reason === 'word' &&
            ((state.result.isRealWord && p === state.result.winner) ||
             (!state.result.isRealWord && p === state.result.loser));
          if (showResultWord) {
            card.appendChild(resultWordRow());
          }
          const msg = document.createElement('div');
          msg.style.marginTop = '8px';
          msg.style.fontWeight = '400';
          msg.style.fontSize = '11px';
          if (state.result.reason === 'draw') {
            msg.style.color = '#0f172a';
            msg.innerHTML = 'You both fell asleep while making your sandwich!<br/>No points for you!';
          } else if (state.result.reason === 'timeout') {
            msg.style.color = p === state.result.winner ? '#166534' : '#9f1239';
            msg.innerHTML = p === state.result.winner
              ? `Player <strong>${playerName(state.result.slowPlayer)}</strong> is too slow, You eat their sandwich`
              : `You snooze, you lose!`;
          } else if (state.result.isRealWord) {
            msg.style.color = p === state.result.winner ? '#166534' : '#9f1239';
            const outcomeLine = p === state.result.winner
              ? 'makes a delicious sandwich.'
              : 'No sandwich for you.';
            msg.innerHTML = outcomeLine;
          } else {
            msg.style.color = p === state.result.winner ? '#166534' : '#9f1239';
            if (p === state.result.winner) {
              msg.innerHTML = `<strong>${playerName(state.result.defender)}</strong> can't spell. You get the sandwich.`;
            } else {
              msg.innerHTML = `isn't a real word.`;
            }
          }
          card.appendChild(msg);
        }

        if (state.ended && (state.winner === p || state.winner === null)) {
          const nextBtn = document.createElement('button');
          nextBtn.className = 'btn warn';
          nextBtn.style.marginTop = '6px';
          nextBtn.textContent = 'New Round';
          nextBtn.onclick = resetRound;
          card.appendChild(nextBtn);
        }

        if (
          state.ended &&
          state.result &&
          p === state.result.winner &&
          state.result.isRealWord &&
          state.result.wordInfo
        ) {
          const info = state.result.wordInfo;
          const infoBox = document.createElement('div');
          infoBox.className = 'word-info';

          const addRow = (label, value) => {
            const row = document.createElement('div');
            const labelEl = document.createElement('span');
            labelEl.className = 'label';
            labelEl.textContent = `${label}: `;
            row.appendChild(labelEl);
            row.appendChild(document.createTextNode(value || 'N/A'));
            infoBox.appendChild(row);
          };

          addRow('Definition', info.definition);
          addRow('Type', info.partOfSpeech);
          addRow('Language', info.language);
          addRow('Source', info.source);
          card.appendChild(infoBox);
        }

        cards.appendChild(card);
      });
    }

    function endSummaryText() {
      const r = state.result;
      if (!r) return 'Round ended';
      const wordText = r.word ? `"${(r.word || '').toUpperCase()}"` : '';
      if (r.reason === 'word') {
        return {
          title: `${playerName(r.winner)} wins!`,
          detail: wordText
            ? (r.isRealWord ? `${wordText} is a real word` : `${wordText} isn't a real word`)
            : 'Checks and wins',
        };
      }
      if (r.reason === 'auto-challenge') {
        return {
          title: `${playerName(r.winner)} wins!`,
          detail: `Auto-challenge on ${playerName(r.slowPlayer)}${wordText ? ` with ${wordText}` : ''}`,
        };
      }
      if (r.reason === 'timeout') {
        return {
          title: `${playerName(r.winner)} wins!`,
          detail: `${playerName(r.slowPlayer)} timed out`,
        };
      }
      if (r.reason === 'draw') {
        return {
          title: r.cause === 'auto-chain' ? 'Draw - It seems like no one was playing' : `Draw - No points (${r.cause || 'timeout'})`,
          detail: '',
        };
      }
      return { title: 'Round ended', detail: '' };
    }

    function currentMoveText() {
      if (state.ended) return endSummaryText();
      if (state.mode === 'double' && state.doubleOrNothing) {
        return `${playerName(state.doubleOrNothing.winner)} - Double or nothing`;
      }
      const player = state.mode === 'challenge' ? state.challengeDefender : state.turn;
      if (state.letters.length === 0) {
        return `${playerName(player)} - Waiting to enter first letters`;
      }
      const timedPlayer = activeTimedPlayer();
      const timerPart = timedPlayer ? (turnSecondsLeft > 0 ? ` â€¢ ${turnSecondsLeft}s` : '') : '';
      return `${playerName(player)} â€¦ ${timerPart || '...'}`;
    }

    function renderHistory() {
      historyEl.innerHTML = '';
      const title = document.createElement('h3');
      title.textContent = 'Moves';
      historyEl.appendChild(title);

      const livePlayer = state.mode === 'challenge' ? state.challengeDefender : state.turn;
      const firstMain = state.history.find(h => !h.sub);
      const attachLiveAsSub = !state.ended && firstMain && firstMain.player === livePlayer;
      const hasStandaloneCurrentMove = !state.ended && !attachLiveAsSub;

      const ol = document.createElement('ol');
      ol.reversed = true;
      const nonSubCount = state.history.filter(h => !h.sub).length + (hasStandaloneCurrentMove ? 1 : 0);
      ol.start = nonSubCount || 1;

      let currentLi = null;
      let pendingSubs = [];
      let liveSubAttached = false;
      let liveSubParent = null;

      if (hasStandaloneCurrentMove) {
        currentLi = document.createElement('li');
        currentLi.innerHTML = currentMoveText();
        ol.appendChild(currentLi);
      }

      state.history.forEach((h) => {
        if (h.sub && currentLi) {
          const sub = document.createElement('div');
          sub.className = 'history-sub';
          sub.innerHTML = h.fragment ? `${h.text} - ${h.fragment}` : h.text;
          currentLi.appendChild(sub);
          return;
        }
        if (h.sub && !currentLi) {
          pendingSubs.push(h);
          return;
        }
        currentLi = document.createElement('li');
        currentLi.innerHTML = h.fragment ? `${h.text} - ${h.fragment}` : h.text;
        if (!liveSubAttached && attachLiveAsSub && !liveSubParent) liveSubParent = currentLi;
        if (pendingSubs.length) {
          for (let i = pendingSubs.length - 1; i >= 0; i -= 1) {
            const subEntry = pendingSubs[i];
            const sub = document.createElement('div');
            sub.className = 'history-sub';
            sub.innerHTML = subEntry.fragment ? `${subEntry.text} - ${subEntry.fragment}` : subEntry.text;
            currentLi.appendChild(sub);
          }
          pendingSubs = [];
        }
        ol.appendChild(currentLi);
      });

      if (pendingSubs.length && currentLi) {
        for (let i = pendingSubs.length - 1; i >= 0; i -= 1) {
          const subEntry = pendingSubs[i];
          const sub = document.createElement('div');
          sub.className = 'history-sub';
          sub.innerHTML = subEntry.fragment ? `${subEntry.text} - ${subEntry.fragment}` : subEntry.text;
          currentLi.appendChild(sub);
        }
        pendingSubs = [];
      }

      if (!liveSubAttached && attachLiveAsSub && liveSubParent) {
        const liveSub = document.createElement('div');
        liveSub.className = 'history-sub';
        liveSub.innerHTML = currentMoveText();
        liveSubParent.appendChild(liveSub);
        liveSubAttached = true;
      }

      if (state.ended && state.result) {
        const finalDiv = document.createElement('div');
        finalDiv.className = 'history-final';
        const summary = endSummaryText();
        const showDetail = state.result.reason !== 'word';
        finalDiv.innerHTML = (showDetail && summary.detail)
          ? `FINAL - <strong>${summary.title}</strong><br/>${summary.detail}`
          : `FINAL - <strong>${summary.title}</strong>`;
        historyEl.appendChild(finalDiv);
      }

      if (ol.childElementCount) historyEl.appendChild(ol);
    }

    function renderBoard() {
      if (!board) return;
      board.innerHTML = '';
      if (state.letters.length === 0) {
        const placeholder = document.createElement('div');
        placeholder.className = 'cell';
        placeholder.style.borderStyle = 'dashed';
        placeholder.style.opacity = '0.7';
        placeholder.textContent = '?';
        board.appendChild(placeholder);
        return;
      }

      state.letters.forEach((c) => {
        const d = document.createElement('div');
        d.className = `cell ${c.player === 1 ? 'p1' : 'p2'}`;
        d.textContent = c.char;
        board.appendChild(d);
      });
    }

    function render() {
      renderBoard();
      renderCards();
      renderHistory();
      syncTurnTimer();
    }

    langModeSelect.addEventListener('change', () => {
      settings.langMode = langModeSelect.value;
      saveSettings();
    });
    player1NameInput.addEventListener('input', () => {
      settings.names[1] = player1NameInput.value.trim() || 'Player 1';
      saveSettings();
      render();
    });
    player2NameInput.addEventListener('input', () => {
      settings.names[2] = player2NameInput.value.trim() || 'Player 2';
      saveSettings();
      render();
    });
    enableTimerInput.addEventListener('change', () => {
      settings.timerEnabled = enableTimerInput.checked;
      timerSecondsInput.disabled = !settings.timerEnabled;
      turnTimerContext = '';
      saveSettings();
      syncTurnTimer();
    });
    timerSecondsInput.addEventListener('change', () => {
      const next = Math.max(3, Math.min(120, Number(timerSecondsInput.value) || 10));
      settings.timerSeconds = Math.floor(next);
      timerSecondsInput.value = String(settings.timerSeconds);
      turnTimerContext = '';
      saveSettings();
      syncTurnTimer();
    });
    loadSettings();
    player1NameInput.value = settings.names[1];
    player2NameInput.value = settings.names[2];
    langModeSelect.value = settings.langMode;
    enableTimerInput.checked = settings.timerEnabled;
    timerSecondsInput.value = String(settings.timerSeconds);
    timerSecondsInput.disabled = !settings.timerEnabled;
    render();
  </script>
</body>
</html>


